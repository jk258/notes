import{_ as e,c as a,o as t,a4 as l}from"./chunks/framework.DdZcq5U1.js";const m=JSON.parse('{"title":"并发介绍","description":"","frontmatter":{},"headers":[{"level":2,"title":"进程和线程","slug":"进程和线程","link":"#进程和线程","children":[]},{"level":2,"title":"并发和并行","slug":"并发和并行","link":"#并发和并行","children":[]},{"level":2,"title":"协程和线程","slug":"协程和线程","link":"#协程和线程","children":[]}],"relativePath":"go/07-并发编程/7-01并发介绍.md","filePath":"go/07-并发编程/7-01并发介绍.md"}'),o={name:"go/07-并发编程/7-01并发介绍.md"},i=l('<h1 id="并发介绍" tabindex="-1">并发介绍 <a class="header-anchor" href="#并发介绍" aria-label="Permalink to &quot;并发介绍&quot;">​</a></h1><h2 id="进程和线程" tabindex="-1">进程和线程 <a class="header-anchor" href="#进程和线程" aria-label="Permalink to &quot;进程和线程&quot;">​</a></h2><ol><li>进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。</li><li>线程是进程的一个执行实体,是 CPU 调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。</li><li>一个进程可以创建和撤销多个线程;同一个进程中的多个线程之间可以并发执行。</li></ol><h2 id="并发和并行" tabindex="-1">并发和并行 <a class="header-anchor" href="#并发和并行" aria-label="Permalink to &quot;并发和并行&quot;">​</a></h2><ul><li>多线程序在一个核的 cpu 上运行，就是并发。</li><li>多线程程序在多个核的 cpu 上运行，就是并行。</li></ul><h2 id="协程和线程" tabindex="-1">协程和线程 <a class="header-anchor" href="#协程和线程" aria-label="Permalink to &quot;协程和线程&quot;">​</a></h2><p>协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。<br> 线程：一个线程上可以跑多个协程，协程是轻量级的线程。</p><p>goroutine 只是由官方实现的超级&quot;线程池&quot;。<br> 每个实力 4~5KB 的栈内存占用和由于实现机制而大幅减少的创建和销毁开销是 go 高并发的根本原因。</p><p>并发不是并行：<br> 并发主要由切换时间片来实现&quot;同时&quot;运行，并行则是直接利用多核实现多线程的运行，go 可以设置使用核数，以发挥多核计算机的能力。</p><p>goroutine 奉行通过通信来共享内存，而不是共享内存来通信。</p>',10),r=[i];function n(c,s,_,h,d,u){return t(),a("div",null,r)}const f=e(o,[["render",n]]);export{m as __pageData,f as default};
