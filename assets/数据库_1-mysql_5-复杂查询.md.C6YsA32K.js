import{_ as i,c as a,a2 as n,o as l}from"./chunks/framework.D-H4MxKu.js";const p="/notes/assets/1705734794437.BbcsRrnU.png",e="/notes/assets/1705738506539.BDDTKC3s.png",g=JSON.parse('{"title":"复杂查询","description":"","frontmatter":{},"headers":[{"level":2,"title":"视图","slug":"视图","link":"#视图","children":[{"level":3,"title":"视图和表","slug":"视图和表","link":"#视图和表","children":[]},{"level":3,"title":"创建视图的方法","slug":"创建视图的方法","link":"#创建视图的方法","children":[]},{"level":3,"title":"视图的限制","slug":"视图的限制","link":"#视图的限制","children":[{"level":4,"title":"定义视图时不能使用ORDER BY子句","slug":"定义视图时不能使用order-by子句","link":"#定义视图时不能使用order-by子句","children":[]},{"level":4,"title":"对视图进行更新","slug":"对视图进行更新","link":"#对视图进行更新","children":[]}]},{"level":3,"title":"删除视图","slug":"删除视图","link":"#删除视图","children":[]}]},{"level":2,"title":"子查询","slug":"子查询","link":"#子查询","children":[{"level":3,"title":"标量子查询","slug":"标量子查询","link":"#标量子查询","children":[]}]},{"level":2,"title":"关联子查询","slug":"关联子查询","link":"#关联子查询","children":[]}],"relativePath":"数据库/1-mysql/5-复杂查询.md","filePath":"数据库/1-mysql/5-复杂查询.md"}'),t={name:"数据库/1-mysql/5-复杂查询.md"};function h(k,s,r,d,E,c){return l(),a("div",null,s[0]||(s[0]=[n('<h1 id="复杂查询" tabindex="-1">复杂查询 <a class="header-anchor" href="#复杂查询" aria-label="Permalink to &quot;复杂查询&quot;">​</a></h1><h2 id="视图" tabindex="-1">视图 <a class="header-anchor" href="#视图" aria-label="Permalink to &quot;视图&quot;">​</a></h2><h3 id="视图和表" tabindex="-1">视图和表 <a class="header-anchor" href="#视图和表" aria-label="Permalink to &quot;视图和表&quot;">​</a></h3><p>从SQL的角度来看<strong>视图</strong>就是一张表。在SQL语句中并不需要区分哪些是表，哪些是数据</p><p>视图和表的不同在于“是否保存了实际的数据”。</p><p>通常，在创建表时，会通过 <code>INSERT</code>语句将数据保存到数据库之中，而数据库中的数据实际上会被保存到计算机的<strong>存储设备</strong>(通常是硬盘)中。因此，通过 <code>SELECT</code>语句查询数据时，实际上就是匆匆存储设备（硬盘）中读取数据，进行各种计算之后，在将结果发发你会给用户这样一个过程。</p><p>但时使用视图时并不会将数据保存到存储设备中，而且也不会将数据保存到其他任何地方。实际上视图保存的时 <code>SELECT</code>语句，我们从视图从视图中读取数据时，视图会在内部执行该 <code>SELECT</code>语句并创建出一张临时表</p><p><img src="'+p+`" alt="1705734794437"></p><p>视图的优点有两个：</p><ul><li>由于视图无需保存数据，因此可以节省存储设备的容量，</li><li>可以将频繁使用的 <code>SELECT</code>语句保存成视图，这样就不用每次都重新书写了。创建好视图之后，只需在 <code>SELECT</code>语句中进行调用，就可以方便地得到想要的结果了</li></ul><h3 id="创建视图的方法" tabindex="-1">创建视图的方法 <a class="header-anchor" href="#创建视图的方法" aria-label="Permalink to &quot;创建视图的方法&quot;">​</a></h3><p>创建视图需要使用 <code>CREATE VIEW</code> 语句，语法如下</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> VIEW</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 视图名称</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">视图列名1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">视图列名2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SELECT语句</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>SELECT</code>语句需要书写在 <code>AS</code>关键字之后。<code>SELECT</code>语句中列的排列顺序和视图中列的排序顺序相同。视图的列名在视图名称之后的列表中定义</p><p>例如，创建ProductSum视图</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> VIEW</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ProductSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(product_type,cnt_product) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">COUNT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">GROUP BY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>使用视图</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type,cnt_product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ProductSum</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>创建出视图之后，就可以通过非常简单的 <code>SELECT</code>语句。随时得到想要的汇总结果，并且，Product表中的数据更新之后，视图也会自动更新，飞铲灵活方便</p><p>在 <code>FROM</code>子句中使用视图的查询，通常有两个步骤</p><ul><li>首先执行定义视图的 <code>SELECT</code>语句</li><li>根据得到的结果，再执行再FROM子句中使用视图的 <code>SELECT</code>语句。也就是说，使用视图的查询通常需要执行 2 条以上的SELECT语句</li></ul><p>同时，还可能出现以视图为基础创建视图的<strong>多重视图</strong>。虽然语法上没有错误，但是我们还是应该尽量避免再视图的基础上创建视图，因为对多数DBMS来说，多重视图会降低SQL的性能</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> VIEW</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ProductSumJim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (product_type, cnt_product)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type, cnt_product</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ProductSum</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;办公用品&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="视图的限制" tabindex="-1">视图的限制 <a class="header-anchor" href="#视图的限制" aria-label="Permalink to &quot;视图的限制&quot;">​</a></h3><h4 id="定义视图时不能使用order-by子句" tabindex="-1">定义视图时不能使用ORDER BY子句 <a class="header-anchor" href="#定义视图时不能使用order-by子句" aria-label="Permalink to &quot;定义视图时不能使用ORDER BY子句&quot;">​</a></h4><p>再定义视图时可以使用任何 <code>SELECT</code>子句，但有一种情况例外，那就是不能使用 <code>ORDER BY</code>子句</p><p>因为视图和表一样，数据行都是没有顺序的。</p><h4 id="对视图进行更新" tabindex="-1">对视图进行更新 <a class="header-anchor" href="#对视图进行更新" aria-label="Permalink to &quot;对视图进行更新&quot;">​</a></h4><p>在 <code>SELECT</code>语句中视图可以和表一样使用。但是，对于INSERT、DELETE、UPDATE这类更新语句来说这其中有很严格的限制。</p><p>标准SQL中有这样的规定：如果定义视图的 <code>SELECT</code>语句能够满足某些条件，那么这个视图就可以被更新。比如：</p><ul><li>SELECT子句中未使用DISTINCT</li><li>FROM子句中只有一张表</li><li>未使用GROUP BY子句</li><li>未使用HAVING子句</li></ul><p>ps：视图和表需要同时进行更新，因此通过汇总得到的视图无法进行更新，不是通过汇总得到的视图就可以进行更新</p><h3 id="删除视图" tabindex="-1">删除视图 <a class="header-anchor" href="#删除视图" aria-label="Permalink to &quot;删除视图&quot;">​</a></h3><p>删除视图需要使用 <code>DROP VIEW</code> 语句，语法如下</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">DROP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> VIEW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 视图名称(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">视图列名1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">视图列名2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,...)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>例如</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">DROP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> VIEW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ProductSum</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="子查询" tabindex="-1">子查询 <a class="header-anchor" href="#子查询" aria-label="Permalink to &quot;子查询&quot;">​</a></h2><p>子查询就是一次性视图(SELECT语句)。与视图不同，子查询在SELECT语句执行完毕之后就会消失</p><p>由于子查询需要命名，因此需要根据处理内容来指定恰当的名称</p><p>标量子查询就是只能返回一行一列的子查询</p><p>如下：</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type,cnt_product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">COUNT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cnt_product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">GROUP BY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ProductSum</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>子查询就是将用来定义视图的 <code>SELECT</code>语句直接用于 <code>FROM</code>子句当中。虽然 <code>AS ProductSum</code>就是子查询的名称，但由于该名称时一次性的，因此不会像视图那样保存在存储介质(硬盘)中，二十在SELECT语句执行之后就消失了</p><p>实际上，该SELECT语句包含嵌套的结构，首先会执行FROM子句中的SELECT语句，然后才会执行外层的SELECT语句，如下：</p><p><img src="`+e+`" alt="1705738506539"></p><p>由于子查询的层数原则上没有限制，因此可以像”子查询的FROM子句中还可以继续使用子查询，该子查询的FROM子句中还可以在使用子查询......“这样无线嵌套下去</p><h3 id="标量子查询" tabindex="-1">标量子查询 <a class="header-anchor" href="#标量子查询" aria-label="Permalink to &quot;标量子查询&quot;">​</a></h3><p>标量就是单一的意思，在数据库之外的领域也经常使用</p><p>子查询基本上都会返回多行结果（虽然偶尔也会值返回 1 行数据）。由于结构和表相同，因此也会有查询不到结果的情况</p><p>而标量子查询则有一个特殊的限制，那就是<strong>必须而且只能返回1行1列的结果</strong>，也就是返回表中某一行的某一列的值，例如&quot;10&quot;这样的值</p><p>由于返回的时单一的值，因此标量子查询的返回值可以用在 = 或者 &lt;&gt; 这样需要单一值的比较运算符之中。这也正是标量子查询的优势所在</p><p>在WHERE子句中使用标量子查询，例如：计算单价高于平均单价的商品</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_id,product_name,sale_price </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sale_price</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AVG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sale_price) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Product)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>标量子查询的书写位置并不仅仅局限于WHERE子句中，通常任何可以使用单一值的位置都可以使用。也就是说，能够使用常数或者列名的地方，无论时SELECT子句、GROUP BY 子句、HAVING子句，还是ORDER BY子句，几乎所有的地方都可以使用，例如</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AVG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sale_price)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Product</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> GROUP BY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">HAVING</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AVG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sale_price) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AVG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sale_price)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Product);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>ps：注意，标量子查询绝对不能返回多行结果。也就是说，如果子查询返回了多行结果，那么就不再是标量子查询，而仅仅是一个普通的子查询了。</p><h2 id="关联子查询" tabindex="-1">关联子查询 <a class="header-anchor" href="#关联子查询" aria-label="Permalink to &quot;关联子查询&quot;">​</a></h2><p>关联子查询会在细分的组内进行比较时使用</p><p>关联子查询和 <code>GROUP BY</code>子句一样，也可以对表中的数据进行切分</p><p>关联子查询的结合条件如果未出现在子查询之中就会发生错误</p><p>如下，通过关联子查询按照商品种类对平均销售单价进行比较</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type,product_name,sale_price </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> P1 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sale_price </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AVG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sale_price) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> P2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> P1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">product_type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">product_type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> GROUP BY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这里起到关键作用的就是<strong>在子查询中添加的WHERE子句的条件</strong>。该条件的意思就是，<strong>在同一商品种类中</strong>对各商品的销售单价和平均单价进行比较</p><p>关联子查询也是用来对集合进行切分的</p><p>ps：结合条件一定要写在子查询中，也就是说子查询内部设定的关联名称，只能在该子查询内部使用，如果将子查询中的关联条件移到了外层查询中，就会违反关联名称的作用域，会发生错误，如下</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type, product_name, sale_price</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> P1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> WHERE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> P1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">product_type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> P2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">product_type</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> AND</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sale_price </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AVG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sale_price)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> P2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> GROUP BY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product_type);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div>`,67)]))}const u=i(t,[["render",h]]);export{g as __pageData,u as default};
